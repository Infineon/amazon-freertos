/*
FreeRTOS+TCP V2.0.11
Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 http://aws.amazon.com/freertos
 http://www.FreeRTOS.org
*/

/*
 * Copyright (c) 2015-2019, Infineon Technologies AG
 * All rights reserved.                        
 *                                             
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *                                                                              
 * To improve the quality of the software, users are encouraged to share 
 * modifications, enhancements or bug fixes with Infineon Technologies AG 
 * at XMCSupport@infineon.com.
 *****************************************************************************/

#include <limits.h>

/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "list.h"
#include "semphr.h"

/* FreeRTOS+TCP includes. */
#include "FreeRTOS_IP.h"
#include "FreeRTOS_IP_Private.h"
#include "NetworkBufferManagement.h"

#include "ethernet.h"
#include "NetworkInterface.h"

#define MAC_ADDR    ((uint64_t)configMAC_ADDR0 | \
                     ((uint64_t)configMAC_ADDR1 << 8) | \
                     ((uint64_t)configMAC_ADDR2 << 16) | \
                     ((uint64_t)configMAC_ADDR3 << 24) | \
                     ((uint64_t)configMAC_ADDR4 << 32) | \
                     ((uint64_t)configMAC_ADDR5 << 40))

#ifndef configNUM_RX_DESCRIPTORS
#error "ERROR: Define configNUM_RX_DESCRIPTORS in your FreeRTOSIPConfig.h"
#endif

#ifndef configNUM_TX_DESCRIPTORS
#error "ERROR: define configNUM_TX_DESCRIPTORS in your FreeRTOSIPConfig.h"
#endif


#if defined(__ICCARM__)
#pragma data_alignment=4
static XMC_ETH_MAC_DMA_DESC_t eth_rx_desc[configNUM_RX_DESCRIPTORS] @ ".dram";
#pragma data_alignment=4
static XMC_ETH_MAC_DMA_DESC_t eth_tx_desc[configNUM_TX_DESCRIPTORS] @ ".dram";
#if( ipconfigZERO_COPY_RX_DRIVER == 0 )
#pragma data_alignment=4
static uint8_t eth_rx_buf[configNUM_RX_DESCRIPTORS][XMC_ETH_MAC_BUF_SIZE] @ ".dram";
#endif
#if( ipconfigZERO_COPY_TX_DRIVER == 0 )
#pragma data_alignment=4
static uint8_t eth_tx_buf[configNUM_TX_DESCRIPTORS][XMC_ETH_MAC_BUF_SIZE] @ ".dram";
#endif
#elif defined(__CC_ARM) || (defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
static __ALIGNED(4) XMC_ETH_MAC_DMA_DESC_t eth_rx_desc[configNUM_RX_DESCRIPTORS] __attribute__((section ("RW_IRAM1")));
static __ALIGNED(4) XMC_ETH_MAC_DMA_DESC_t eth_tx_desc[configNUM_TX_DESCRIPTORS] __attribute__((section ("RW_IRAM1")));
#if( ipconfigZERO_COPY_RX_DRIVER == 0 )
static __ALIGNED(4) uint8_t eth_rx_buf[configNUM_RX_DESCRIPTORS][XMC_ETH_MAC_BUF_SIZE] __attribute__((section ("RW_IRAM1")));
#endif
#if( ipconfigZERO_COPY_TX_DRIVER == 0 )
static __ALIGNED(4) uint8_t eth_tx_buf[configNUM_TX_DESCRIPTORS][XMC_ETH_MAC_BUF_SIZE] __attribute__((section ("RW_IRAM1")));
#endif
#elif defined(__GNUC__)
static __ALIGNED(4) XMC_ETH_MAC_DMA_DESC_t eth_rx_desc[configNUM_RX_DESCRIPTORS] __attribute__((section ("ETH_RAM")));
static __ALIGNED(4) XMC_ETH_MAC_DMA_DESC_t eth_tx_desc[configNUM_TX_DESCRIPTORS] __attribute__((section ("ETH_RAM")));
#if( ipconfigZERO_COPY_RX_DRIVER == 0 )
static __ALIGNED(4) uint8_t eth_rx_buf[configNUM_RX_DESCRIPTORS][XMC_ETH_MAC_BUF_SIZE] __attribute__((section ("ETH_RAM")));
#endif
#if( ipconfigZERO_COPY_TX_DRIVER == 0 )
static __ALIGNED(4) uint8_t eth_tx_buf[configNUM_TX_DESCRIPTORS][XMC_ETH_MAC_BUF_SIZE] __attribute__((section ("ETH_RAM")));
#endif
#endif

#define TX_BUFFER_FREE_WAIT ( pdMS_TO_TICKS( 5UL ) )
#define MAX_TX_ATTEMPTS     ( 10 )

/* If ipconfigETHERNET_DRIVER_FILTERS_FRAME_TYPES is set to 1, then the Ethernet
driver will filter incoming packets and only pass the stack those packets it
considers need processing. */
#if( ipconfigETHERNET_DRIVER_FILTERS_FRAME_TYPES == 0 )
#define ipCONSIDER_FRAME_FOR_PROCESSING( pucEthernetBuffer ) eProcessBuffer
#else
#define ipCONSIDER_FRAME_FOR_PROCESSING( pucEthernetBuffer ) eConsiderFrameForProcessing( ( pucEthernetBuffer ) )
#endif

static TaskHandle_t netif_task_handler = NULL;
static XMC_ETH_LINK_STATUS_t link_status = XMC_ETH_LINK_STATUS_DOWN;

/* xTXDescriptorSemaphore is a counting semaphore with
   a maximum count of TX_DESC_CNT, which is the number of
  DMA TX descriptors. */
static SemaphoreHandle_t xTXDescriptorSemaphore = NULL;

static uint32_t ulTxDescriptorToClear = 0;

void ETH0_0_IRQHandler(void)
{
  BaseType_t xHigherPriorityTaskWoken;
  uint32_t ulStatusRegister;

  ulStatusRegister = XMC_ETH_MAC_GetEventStatus(&eth_mac);
  XMC_ETH_MAC_ClearEventStatus(&eth_mac, ulStatusRegister);

  /* xHigherPriorityTaskWoken must be initialised to pdFALSE.  If calling
     xTaskNotifyFromISR() unblocks the handling task, and the priority of
     the handling task is higher than the priority of the currently running task,
     then xHigherPriorityTaskWoken will automatically get set to pdTRUE. */
  xHigherPriorityTaskWoken = pdFALSE;

  /* Unblock the handling task so the task can perform any processing necessitated
     by the interrupt.  xHandlingTask is the task's handle, which was obtained
     when the task was created.  The handling task's notification value
     is bitwise ORed with the interrupt status - ensuring bits that are already
     set are not overwritten. */
  xTaskNotifyFromISR(netif_task_handler, ulStatusRegister, eSetBits, &xHigherPriorityTaskWoken );

  /* Force a context switch if xHigherPriorityTaskWoken is now set to pdTRUE.
     The macro used to do this is dependent on the port and may be called
     portEND_SWITCHING_ISR. */
  portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

#if (ipconfigZERO_COPY_RX_DRIVER == 0)
static BaseType_t prvNetworkInterfaceInput(void)
{
  uint32_t xReceivedLength;
  uint8_t *pucBuffer;
  NetworkBufferDescriptor_t *pxDescriptor;
  const TickType_t xDescriptorWaitTime = pdMS_TO_TICKS( 250 );
  xIPStackEvent_t xRxEvent = { eNetworkRxEvent, NULL };

  xReceivedLength = XMC_ETH_MAC_GetRxFrameSize(&eth_mac);

  if ((xReceivedLength > 0) && (xReceivedLength <= XMC_ETH_MAC_BUF_SIZE))
  {
    pucBuffer = XMC_ETH_MAC_GetRxBuffer(&eth_mac);

    if (ipCONSIDER_FRAME_FOR_PROCESSING(pucBuffer))
    {
      pxDescriptor = pxGetNetworkBufferWithDescriptor(xReceivedLength, xDescriptorWaitTime);
      if (pxDescriptor != NULL)
      {
        memcpy(pxDescriptor->pucEthernetBuffer, pucBuffer, xReceivedLength);

        pxDescriptor->xDataLength = xReceivedLength;
        xRxEvent.pvData = ( void * )pxDescriptor;

        /* Pass the data to the TCP/IP task for processing. */
        if (xSendEventStructToIPTask( &xRxEvent, xDescriptorWaitTime ) == pdFALSE)
        {
          /* Could not send the descriptor into the TCP/IP stack, it must be released. */
          vReleaseNetworkBufferAndDescriptor(pxDescriptor);
          iptraceETHERNET_RX_EVENT_LOST();
        }
        else
        {
          iptraceNETWORK_INTERFACE_RECEIVE();
        }
      }
    }
  }

  XMC_ETH_MAC_ReturnRxDescriptor(&eth_mac);
  XMC_ETH_MAC_ResumeRx(&eth_mac);

	return ( xReceivedLength > 0 );

}
#else
static BaseType_t prvNetworkInterfaceInput(void)
{
  uint32_t xReceivedLength;
  uint8_t *pucBuffer;
  NetworkBufferDescriptor_t *pxCurDescriptor;
  NetworkBufferDescriptor_t *pxNewDescriptor = NULL;

  xIPStackEvent_t xRxEvent = { eNetworkRxEvent, NULL };

  xReceivedLength = XMC_ETH_MAC_GetRxFrameSize(&eth_mac);
  if (xReceivedLength > 0)
  {
    /* Check if it is a valid frame */
    if (xReceivedLength <= ipTOTAL_ETHERNET_FRAME_SIZE)
    {
      pucBuffer = XMC_ETH_MAC_GetRxBuffer(&eth_mac);

      if (ipCONSIDER_FRAME_FOR_PROCESSING(pucBuffer))
      {
        /* Allocate a new network buffer descriptor that references an Ethernet
           frame large enough to hold the maximum network packet size (as defined
           in the FreeRTOSIPConfig.h header file). */
        pxNewDescriptor = pxGetNetworkBufferWithDescriptor(ipTOTAL_ETHERNET_FRAME_SIZE, 0);
        if (pxNewDescriptor != NULL)
        {
          XMC_ETH_MAC_SetRxBuffer(&eth_mac, pxNewDescriptor->pucEthernetBuffer);

			    pxCurDescriptor = pxPacketBuffer_to_NetworkBuffer( pucBuffer );
			    configASSERT( pxCurDescriptor != NULL );

          pxCurDescriptor->xDataLength = xReceivedLength;

          /*
           * The network buffer descriptor now points to the Ethernet buffer that
           * contains the received data, and the Ethernet DMA descriptor now points
           * to a newly allocated (and empty) Ethernet buffer ready to receive more
           * data.  No data was copied.  Only pointers to data were swapped.
           */

          xRxEvent.pvData = ( void * )pxCurDescriptor;

          /* Pass the data to the TCP/IP task for processing. */
          if (xSendEventStructToIPTask( &xRxEvent, xDescriptorWaitTime ) == pdFALSE)
          {
            /* Could not send the descriptor into the TCP/IP stack, it must be released. */
            vReleaseNetworkBufferAndDescriptor(pxCurDescriptor);
            iptraceETHERNET_RX_EVENT_LOST();
          }
          else
          {
            iptraceNETWORK_INTERFACE_RECEIVE();
          }
        }
        else
        {
          /* The event was lost because a network buffer was not available.
             Call the standard trace macro to log the occurrence. */
          iptraceETHERNET_RX_EVENT_LOST();
        }
      }
    }

    XMC_ETH_MAC_ReturnRxDescriptor(&eth_mac);
  }

  XMC_ETH_MAC_ResumeRx(&eth_mac);

	return ( xReceivedLength > 0 );

}
#endif

static void vClearTXBuffers()
{
  size_t uxCount = (( UBaseType_t)configNUM_TX_DESCRIPTORS) - uxSemaphoreGetCount(xTXDescriptorSemaphore);

  /* This function is called after a TX-completion interrupt.
     It will release each Network Buffer used in xNetworkInterfaceOutput().
     'uxCount' represents the number of descriptors given to DMA for transmission.
     After sending a packet, the DMA will clear the 'ETH_DMATXDESC_OWN' bit. */
  while ((uxCount > 0) && (XMC_ETH_MAC_IsTxDescriptorOwnedByDmaEx(&eth_mac, ulTxDescriptorToClear) == pdFALSE))
  {
#if( ipconfigZERO_COPY_TX_DRIVER != 0 )
    uint8_t *ucPayLoad = XMC_ETH_MAC_GetTxBufferEx(&eth_mac, ulTxDescriptorToClear);
    if( ucPayLoad != NULL )
    {
      NetworkBufferDescriptor_t *pxDescriptor = pxPacketBuffer_to_NetworkBuffer(ucPayLoad);
      if (pxDescriptor != NULL)
      {
        vReleaseNetworkBufferAndDescriptor(pxDescriptor);
      }
      XMC_ETH_MAC_SetTxBufferEx(&eth_mac, ulTxDescriptorToClear, 0);
    }
#endif

    /* Move onto the next descriptor, wrapping if necessary. */
    ulTxDescriptorToClear++;
    if (ulTxDescriptorToClear >= configNUM_TX_DESCRIPTORS )
    {
      ulTxDescriptorToClear = 0;
    }

    uxCount--;

    /* Tell the counting semaphore that one more TX descriptor is available. */
    xSemaphoreGive( xTXDescriptorSemaphore );
  }
}

static void set_link_up(void)
{
  while (XMC_ETH_PHY_IsAutonegotiationCompleted(&eth_mac, ETH_PHY_ADDR) == false);

  XMC_ETH_LINK_SPEED_t speed = XMC_ETH_PHY_GetLinkSpeed(&eth_mac, ETH_PHY_ADDR);
  XMC_ETH_LINK_DUPLEX_t duplex = XMC_ETH_PHY_GetLinkDuplex(&eth_mac, ETH_PHY_ADDR);

  XMC_ETH_MAC_SetLink(&eth_mac, speed, duplex);

  /* Enable ethernet interrupts */
  XMC_ETH_MAC_EnableEvent(&eth_mac, (uint32_t)(XMC_ETH_MAC_EVENT_RECEIVE | XMC_ETH_MAC_EVENT_RECEIVE_BUFFER_UNAVAILABLE | XMC_ETH_MAC_EVENT_TRANSMIT));

  NVIC_SetPriority(ETH0_0_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 62U, 0U));
  NVIC_ClearPendingIRQ(ETH0_0_IRQn);
  NVIC_EnableIRQ(ETH0_0_IRQn);

  XMC_ETH_MAC_EnableTx(&eth_mac);
  XMC_ETH_MAC_EnableRx(&eth_mac);

  link_status = XMC_ETH_LINK_STATUS_UP;
}

static void set_link_down(void)
{
  XMC_ETH_MAC_DisableEvent(&eth_mac, (uint32_t)(XMC_ETH_MAC_EVENT_RECEIVE | XMC_ETH_MAC_EVENT_RECEIVE_BUFFER_UNAVAILABLE | XMC_ETH_MAC_EVENT_TRANSMIT));
  NVIC_DisableIRQ(ETH0_0_IRQn);

  XMC_ETH_MAC_DisableTx(&eth_mac);
  XMC_ETH_MAC_DisableRx(&eth_mac);

  link_status = XMC_ETH_LINK_STATUS_DOWN;
}

static void netif_task(void *arg)
{
  (void)arg;
  uint32_t ulInterruptStatus;

  while (1)
  {
    /* Block indefinitely (without a timeout, so no need to check the function's
     return value) to wait for a notification.  NOTE!  Real applications
     should not block indefinitely, but instead time out occasionally in order
     to handle error conditions that may prevent the interrupt from sending
     any more notifications. */
    xTaskNotifyWait(0,                  /* Don't clear any bits on entry. */
                    UINT_MAX,           /* Clear all bits on exit. */
                    &ulInterruptStatus, /* Receives the notification value. */
                    portMAX_DELAY);     /* Block indefinitely. */

    if ((ulInterruptStatus & (XMC_ETH_MAC_EVENT_RECEIVE | XMC_ETH_MAC_EVENT_RECEIVE_BUFFER_UNAVAILABLE)) != 0)
    {
	  	while (prvNetworkInterfaceInput());
    }

    if ((ulInterruptStatus & XMC_ETH_MAC_EVENT_TRANSMIT) != 0 )
    {
      /* Check if DMA packets have been delivered. */
      vClearTXBuffers();
    }
  }
}


BaseType_t xNetworkInterfaceInitialise( void )
{
  if (netif_task_handler == NULL)
  {
    if( xTXDescriptorSemaphore == NULL )
    {
      xTXDescriptorSemaphore = xSemaphoreCreateCounting( ( UBaseType_t ) configNUM_TX_DESCRIPTORS, ( UBaseType_t ) configNUM_TX_DESCRIPTORS );
      configASSERT( xTXDescriptorSemaphore );
    }

    /* Initialize network interfaces */
    if (xTaskCreate(netif_task, "netif_task", configMINIMAL_STACK_SIZE, NULL, configMAX_PRIORITIES - 1, &netif_task_handler) != pdPASS)
    {
      return pdFALSE;
    }

    // Configure ethernet port
    eth_mac.rx_desc = eth_rx_desc;
    eth_mac.tx_desc = eth_tx_desc;
#if( ipconfigZERO_COPY_RX_DRIVER == 0 )
    eth_mac.rx_buf = &eth_rx_buf[0][0];
#else
    eth_mac.rx_buf = NULL;
#endif
#if( ipconfigZERO_COPY_TX_DRIVER == 0 )
    eth_mac.tx_buf = &eth_tx_buf[0][0];
#else
    eth_mac.tx_buf = NULL;
#endif
    eth_mac.num_rx_buf = configNUM_RX_DESCRIPTORS;
    eth_mac.num_tx_buf = configNUM_TX_DESCRIPTORS;
    eth_mac.address = MAC_ADDR;

    XMC_ETH_MAC_InitEx(&eth_mac);
    XMC_ETH_MAC_DisableJumboFrame(&eth_mac);
    XMC_ETH_MAC_SetAddress(&eth_mac, eth_mac.address);

#if( ipconfigZERO_COPY_RX_DRIVER != 0 )
    for (int32_t index = 0; index < configNUM_RX_DESCRIPTORS; ++index)
    {
      NetworkBufferDescriptor_t *pxDescriptor = pxGetNetworkBufferWithDescriptor( ipTOTAL_ETHERNET_FRAME_SIZE, 0 );
      
      /* During start-up there should be enough Network Buffers available,
         so it is safe to use configASSERT().
         In case this assert fails, please check: configNUM_RX_DESCRIPTORS,
         ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS, and in case BufferAllocation_2.c
         is included, check the amount of available heap. */
      configASSERT( pxDescriptor != NULL );

      XMC_ETH_MAC_SetRxBufferEx(&eth_mac, index, pxDescriptor->pucEthernetBuffer);
    }
#endif
  }

  if (xGetPhyLinkStatus() == pdFALSE)
  {
    if (link_status != XMC_ETH_LINK_STATUS_DOWN)
    {
      set_link_down();
      return pdFALSE;
    }
  }
  else
  {
    if (link_status != XMC_ETH_LINK_STATUS_UP)
    {
      set_link_up();

      /* When returning non-zero, the stack will become active and
         start DHCP (if configured) */
      return pdPASS;
    }
  }

  return pdFALSE;
}


#if (ipconfigZERO_COPY_TX_DRIVER == 0)
BaseType_t xNetworkInterfaceOutput( NetworkBufferDescriptor_t * const pxNetworkBuffer, BaseType_t xReleaseAfterSend )
{
  uint8_t *buffer;
  const TickType_t xBlockTimeTicks = pdMS_TO_TICKS(50u);
  BaseType_t xReturn = pdFAIL;

  do
  {
    if (pxNetworkBuffer->xDataLength > XMC_ETH_MAC_BUF_SIZE)
    {
      break;
    }

    if (xTXDescriptorSemaphore == NULL)
    {
      break;
    }

    if (xSemaphoreTake(xTXDescriptorSemaphore, xBlockTimeTicks) != pdPASS)
    {
      /* Time-out waiting for a free TX descriptor. */
      break;
    }

    /* If the descriptor is still owned by the DMA it can't be used. */
    if (XMC_ETH_MAC_IsTxDescriptorOwnedByDma(&eth_mac))
    {
      /* The semaphore was taken, the TX DMA-descriptor is still not available.
         Actually that should not occur, the 'TDES_OWN' was already confirmed low in vClearTXBuffers(). */
      xSemaphoreGive( xTXDescriptorSemaphore );
    }
    else
    {
      buffer = XMC_ETH_MAC_GetTxBuffer(&eth_mac);
      memcpy((void *)buffer, pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuffer->xDataLength);

      XMC_ETH_MAC_SetTxBufferSize(&eth_mac, pxNetworkBuffer->xDataLength);
      XMC_ETH_MAC_ReturnTxDescriptor(&eth_mac);
      XMC_ETH_MAC_ResumeTx(&eth_mac);

      iptraceNETWORK_INTERFACE_TRANSMIT();

      xReturn = pdPASS;
    }
  } while( 0 );

  /* The buffer has been sent so can be released. */
  if (xReleaseAfterSend != pdFALSE)
  {
    vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
  }

  return xReturn;
}

#else
BaseType_t xNetworkInterfaceOutput( NetworkBufferDescriptor_t * const pxDescriptor, BaseType_t xReleaseAfterSend )
{
  (void)xReleaseAfterSend;
  BaseType_t xReturn = pdFAIL;
  int32_t x;

  do
  {
    if (xTXDescriptorSemaphore == NULL)
    {
      break;
    }

  	for (x = 0; x < MAX_TX_ATTEMPTS; ++x)
    {
      if (xSemaphoreTake(xTXDescriptorSemaphore, 0) == pdPASS)
      {
  			break;
      }
      iptraceWAITING_FOR_TX_DMA_DESCRIPTOR();	
      vTaskDelay(TX_BUFFER_FREE_WAIT);
    }

    if (x == MAX_TX_ATTEMPTS)
    {
      break;
    }
    
    /* If the descriptor is still owned by the DMA it can't be used. */
    if (XMC_ETH_MAC_IsTxDescriptorOwnedByDma(&eth_mac))
    {
      /* The semaphore was taken, the TX DMA-descriptor is still not available.
         Actually that should not occur, the 'TDES_OWN' was already confirmed low in vClearTXBuffers(). */
      xSemaphoreGive( xTXDescriptorSemaphore );
    }
    else
    {
      XMC_ETH_MAC_SetTxBuffer(&eth_mac, pxDescriptor->pucEthernetBuffer);
      XMC_ETH_MAC_SetTxBufferSize(&eth_mac, pxDescriptor->xDataLength);

      XMC_ETH_MAC_ReturnTxDescriptor(&eth_mac);
      XMC_ETH_MAC_ResumeTx(&eth_mac);

      iptraceNETWORK_INTERFACE_TRANSMIT();

      xReturn = pdPASS;

    }
  } while(0);

  return xReturn;
}

#endif

/* First statically allocate the buffers, ensuring an additional ipBUFFER_PADDING
bytes are allocated to each buffer.  This example makes no effort to align
the start of the buffers, but most hardware will have an alignment requirement.
If an alignment is required then the size of each buffer must be adjusted to
ensure it also ends on an alignment boundary.  Below shows an example assuming
the buffers must also end on an 8-byte boundary. */
#define BUFFER_SIZE ( ipTOTAL_ETHERNET_FRAME_SIZE + ipBUFFER_PADDING )
#define BUFFER_SIZE_ROUNDED_UP ( ( BUFFER_SIZE + 7 ) & ~0x07UL )
#if defined(__ICCARM__)
#pragma data_alignment=4
static uint8_t ucBuffers[ ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS ][ BUFFER_SIZE_ROUNDED_UP ] @ ".dram";
#elif defined(__CC_ARM) || (defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
static __ALIGNED(4) uint8_t ucBuffers[ ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS ][ BUFFER_SIZE_ROUNDED_UP ] __attribute__((section ("RW_IRAM1")));
#elif defined(__GNUC__)
static __ALIGNED(4) uint8_t ucBuffers[ ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS ][ BUFFER_SIZE_ROUNDED_UP ]  __attribute__((section ("ETH_RAM")));
#endif

/* Next provide the vNetworkInterfaceAllocateRAMToBuffers() function, which
simply fills in the pucEthernetBuffer member of each descriptor. */
void vNetworkInterfaceAllocateRAMToBuffers(
    NetworkBufferDescriptor_t pxDescriptor[ ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS ] )
{
  for( BaseType_t x = 0; x < ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS; ++x )
  {
    /* pucEthernetBuffer is set to point ipBUFFER_PADDING bytes in from the
       beginning of the allocated buffer. */
    pxDescriptor[ x ].pucEthernetBuffer = &( ucBuffers[ x ][ ipBUFFER_PADDING ] );
    pxDescriptor[ x ].xDataLength = 0;
    pxDescriptor[ x ].usPort = 0;
    pxDescriptor[ x ].usBoundPort = 0;

    /* The following line is also required, but will not be required in
       future versions. */
    *( ( uint32_t * ) &ucBuffers[ x ][ 0 ] ) = ( uint32_t ) &( pxDescriptor[ x ] );
  }
}

BaseType_t xGetPhyLinkStatus(void)
{
  if (XMC_ETH_PHY_GetLinkStatus(&eth_mac, ETH_PHY_ADDR) != XMC_ETH_LINK_STATUS_DOWN)
  {
    return pdTRUE;
  }

  return pdFALSE;
}

